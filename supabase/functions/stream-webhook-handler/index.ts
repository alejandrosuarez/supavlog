// Type definitions generated by Hookdeck
type CommonBody = {
  type: string;
  created_at: string;
  call_cid: string;
};

type CallRecordingBody = {
  call_cid: string;
  call_recording: Callrecording;
} & CommonBody;

type CallEndedBody = {
  type: string;
  call: Call;
} & CommonBody;

interface Callrecording {
  filename: string;
  url: string;
  start_time: string;
  end_time: string;
}

interface Call {
  thumbnails: Thumbnails;
}
interface Thumbnails {
  image_url: string;
}

type Body = CallRecordingBody & CallEndedBody;

type FileType = "mp4" | "jpg";

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const VIDEO_BUCKET = "videos";
const VIDEO_TABLE = "videos";

// Create Supabase client
const supabase = createClient(
  Deno.env.get("NEXT_PUBLIC_SUPABASE_URL"),
  Deno.env.get("X_SUPABASE_API_SECRET")
);

// Upload file using standard upload
async function uploadFile(filePath: string, file: ArrayBuffer) {
  const result = await supabase.storage
    .from(VIDEO_BUCKET)
    .upload(filePath, file);
  if (result.error) {
    console.error(result.error);
    throw result.error;
  }
}

const uploadToBucket = async ({
  fileType,
  uploadFilePath,
  userId,
  buffer,
}: {
  fileType: FileType;
  uploadFilePath: string;
  userId: string;
  buffer: ArrayBuffer;
}) => {
  console.log(`Uploading ${fileType} to ${uploadFilePath} for user ${userId}`);

  await uploadFile(uploadFilePath, buffer);

  const storageResult = supabase.storage
    .from(VIDEO_BUCKET)
    .getPublicUrl(uploadFilePath);

  if (storageResult.error) {
    console.error(
      `Error getting public URL for ${fileType}`,
      storageResult.error
    );
    throw new Error(`Error getting public URL for ${fileType}`);
  }
  const publicUrl = storageResult.data.publicUrl;
  console.log(`Supabase public ${fileType} URL`, publicUrl);

  return { publicUrl };
};

const updateVideoDetails = async ({
  fileType,
  callId,
  publicUrl,
}: {
  fileType: FileType;
  callId: string;
  publicUrl: string;
}) => {
  // TODO: see above comment on the user ID. We also don't presently
  // get the call title so can't add this here yet. Update when that
  // info becomes available via the webhook payload.

  // Insert
  // const videoInsertResult = await supabase.from(VIDEO_TABLE).insert({
  //   user_id: userId,
  //   title: "",
  //   description: "",
  //   url: publicUrl,
  //   profile_user_id: userId,
  // });

  // Update
  console.log(`Updating ${fileType} with call ID "${callId}"`);

  let videoUpdateResult = null;
  if (fileType === "mp4") {
    videoUpdateResult = await supabase
      .from(VIDEO_TABLE)
      .update({
        url: publicUrl,
      })
      .eq("call_id", callId);
  } else {
    videoUpdateResult = await supabase
      .from(VIDEO_TABLE)
      .update({
        thumbnail_url: publicUrl,
      })
      .eq("call_id", callId);
  }

  console.log({ videoUpdateResult });

  if (videoUpdateResult.error) {
    // Insert
    // console.error("Error adding video to database", videoInsertResult.error);
    // throw new Error("Error adding video to database");

    // Update
    console.error("Error updating video in database", videoUpdateResult.error);
    throw new Error("Error updating video in database");
  }

  return videoUpdateResult.data;
};

const getStreamUrl = (fileType: FileType, body: Body) => {
  if (fileType === "mp4") {
    return decodeURI(body.call_recording.url);
  }

  return decodeURI(body.call.thumbnails.image_url);
};

const getStreamFilename = (fileType: FileType, body: Body, userId: string) => {
  let filename = `${Date.now()}-`;
  if (fileType === "mp4") {
    filename += body.call_recording.filename.replace(userId, "");
  } else {
    filename += "thumbnail.jpg";
  }
  return filename;
};

const WEBHOOK_EVENTS = ["call.recording_ready", "call.ended"];

Deno.serve(async (req) => {
  const body: Body = await req.json();

  if (WEBHOOK_EVENTS.includes(body.type) === false) {
    console.log("not a call recording, skipping");
    return new Response(
      JSON.stringify({
        success: false,
        message: "Was not a call.recording_ready type event",
      }),
      {
        headers: { "Content-Type": "application/json" },
      }
    );
  }
  console.log("processing webook", { body });

  try {
    const fileType = body.type === "call.recording_ready" ? "mp4" : "jpg";

    let streamUrl = getStreamUrl(fileType, body);
    console.log("requesting stream url", streamUrl);

    const callId = body.call_cid.replace("default:", "");
    // Having to pass the userID in the call ID because the webhook payload
    // doesn't presently include any way to identify the user who created the recording.
    // TODO: remove this in future as the payload should include something to identify the user.
    let userId = callId.replace("call_", "");
    userId = userId.substring(0, callId.lastIndexOf("_"));

    const streamFilename = getStreamFilename(fileType, body, userId);

    const download = await fetch(streamUrl);
    console.log(`Downloaded ${fileType}`);
    if (download.status !== 200) {
      console.error(
        `Error downloading ${fileType}`,
        download.status,
        download.statusText
      );
      throw new Error(`Error downloading ${fileType}`);
    }

    const buffer = await download.arrayBuffer();

    const uploadFilePath = `${userId}/${streamFilename}`;

    const { publicUrl } = await uploadToBucket({
      fileType,
      uploadFilePath,
      userId,
      buffer,
    });

    await updateVideoDetails({ fileType, callId, publicUrl });

    // Insert
    // return new Response(JSON.stringify({ success: true }), {
    //   headers: { "Content-Type": "application/json" },
    //   status: 201,
    // });

    // Update
    return new Response(JSON.stringify({ success: true }), {
      headers: { "Content-Type": "application/json" },
      status: 200,
    });
  } catch (e) {
    console.error("Catch all in webhook handler", e);
    return new Response(JSON.stringify({ success: false }), {
      headers: { "Content-Type": "application/json" },
      status: 500,
    });
  }
});
